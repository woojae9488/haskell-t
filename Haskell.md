# 시작하기

## 준비사항
- 사용할 하스켈 컴파일러 : `GHC` (Glasgow Haskell Compiler)
    - 하스켈 스크립트(`.hs` 확장자를 가진 스크립트) 컴파일 가능
    - 인터랙티브 모드(`GHCi`)도 제공 (`ghci` 명령어를 통해 실행)
- 하스켈 플랫폼 다운로드 : https://www.haskell.org/downloads/

### GHCi 프로그램의 명령어
- `:t ${expression}` : 표현식의 타입을 확인
- `:l ${haskell script}` : 하스켈 스크립트 불러오기 (load)
- `:r` : 하스켈 스크립트 다시 불러오기 (reload)
- `:q` : GHCi 프로그램 종료 (quit)
- `:! ${cmd}` : shell에서 cmd 명령어 실행
- `:set prompt "${prompt format}"` : GHCi 프로그램의 프롬프트 형식 변경

### GHCi 프로그램의 기본 설정 변경
- GHCi 프로그램을 실행하는 홈 디렉터리에 `.ghci`라는 파일을 만든 후 명령어 추가
- 기본적으로 `:set prompt` 명령을 통해 프롬프트 형식을 변경한다.

### 하스켈의 주석
- 하스켈에서 한줄 주석을 처리하기 위해 `-- ${주석 내용}` 키워드를 사용한다.
- 여러 줄 주석을 처리하기 위해서는 `{- ${주석 내용} -}` 키워드를 사용한다.
<br><br>


## 함수 호출하기
- 중위 함수(infix function) : 함수명이 매개변수 2개 사이에 오는 함수
    - 기본적인 연산자들이 중위 함수로 작동한다.
- 전위 함수(prefix function) : 함수명이 매개변수들 앞에 오는 함수
    - 대부분의 함수들은 전위 함수로 작동한다.
    - 2개의 매개변수를 받는 전위 함수는 역 따옴표(`)로 함수명을 감싸면 중위 함수처럼 사용할 수 있다.
        - ex) `div 50 10`은 ``50 `div` 10``과 동일하다.
- 함수명은 대문자로 시작할 수 없으며, 어퍼스트로피(')는 함수명으로 유요한 문자이다.
- 함수명 끝에 어퍼스트로피를 붙이면 비슷한 이름을 가진 함수의 약간 다른 버전을 의미한다.
- 특정 함수가 특수 문자만으로 구성되어 있다면 기본적으로 중위 함수로 간주된다.
    - 중위 함수의 타입 서명을 보고 싶거나, 전위 함수처럼 호출하고 싶다면 소괄호(`()`)로 감싸줘야 한다.
<br><br>


## 조건문 if 문
- 구문 : `if ${조건식} then ${참 값} else ${거짓 값}`
- 하스켈에서는 if 문에서 else 부분이 필수적이다.
- 하스켈의 if 문은 값을 반환해야 하는 표현식으로 동작한다.
<br><br>


## 리스트 소개
- 리스트는 같은 종류의 데이터 구조이다. (동일한 타입의 여러 항목들을 가지고 있다.)
- 리스트는 대괄호로 둘러 쌓이며, 리스트의 값은 콤마로 구분된다.
    - ex) `myList = [1, 2, 3, 4, 5]`
- 하스켈에서 문자열은 문자들의 리스트와 동일하다.
    - ex) `"hello" == ['h', 'e', 'l', 'l', 'o']`

### 리스트 연결
- `++` 연산자를 사용하여 리스트 2개를 연결할 수 있다.
    - ex) `[1, 2, 3] ++ [4, 5, 6] == [1, 2, 3, 4, 5, 6]`
- 긴 문자열에서 `++` 연산자를 반복적으로 사용하는 것은 지양해야 한다.
    - `++` 연산자는 첫 번째 리스트 전체를 읽어들여야 하기 때문이다.
- `:` 연산자(cons 연산자)를 사용하여 리스트의 시작 부분에 항목을 추가할 수 있다.
    - ex) `1:[2, 3, 4, 5] == [1, 2, 3, 4, 5]`
    - `:` 연산자는 리스트 전체를 읽어들이지 않고 즉각적으로 항목이 추가된다.

### 리스트 항목에 접근하기
- `!!` 연산자를 사용하면 리스트 항목을 인덱스로 접근할 수 있다.
    - ex) `[1, 2, 3, 4, 5] !! 0 == 1`

### 리스트 안의 리스트
- 리스트는 리스트를 항목으로 가질 수 있으며, 리스트를 항목으로 가진 리스트를 가질 수 있다.
    - ex) `matrix = [[1, 2], [3, 4], [5, 6]]`
- 리스트에 있는 리스트의 길이는 다를 수 있지만, 타입은 같아야 한다.

### 리스트 비교하기
- 리스트가 담고 있는 항목이 비교될 수 있다면 리스트도 비교될 수 있다.
- 2개의 리스트를 비교하기 위해 `<`, `<=`, `>`, `>=` 연산자를 사용하면 사전적 순서로 비교하게 된다.
    - 첫 번째 항목부터 시작해서 다음 항목들을 순차적으로 비교한다.
- 비어있지 않은 리스트는 비어있는 리스트보다 항상 크다고 간주된다.

### 더 많은 리스트 연산
- `head` 함수는 리스트를 받아서 첫 번째 항목을 반환한다.
    - ex) `head [1, 2, 3, 4, 5] == 1`
- `tail` 함수는 리스트를 받아서 첫 번째 항목을 제외한 나머지를 반환한다.
    - ex) `tail [1, 2, 3, 4, 5] == [2, 3, 4, 5]`
- `last` 함수는 리스트를 받아서 제일 마지막 항목을 반환한다.
    - ex) `last [1, 2, 3, 4, 5] == 5`
- `init` 함수는 리스트를 받아서 제일 마지막 항목을 제외한 나머지를 반환한다.
    - ex) `init [1, 2, 3, 4, 5] == [1, 2, 3, 4]`
- 위 4개의 함수들은 비어있는 리스트가 인자로 전달 시 에러가 던져진다.
- `length` 함수는 리스트를 받아서 그 길이를 반환한다.
    - ex) `length [1, 2, 3, 4, 5] == 5`
- `null` 함수는 리스트가 비어있는지 검사한다.
    - ex) `null [1, 2, 3, 4, 5] == False`
- `reverse` 함수는 리스트를 역순으로 만든다.
    - ex) `reverse [1, 2, 3, 4, 5] == [5, 4, 3, 2, 1]`
- `take` 함수는 숫자와 리스트를 받아 리스트의 시작 부분부터 주어진 숫자까지의 항목을 추출한다.
    - ex) `take 3 [1, 2, 3, 4, 5] == [1, 2, 3]`
    - 리스트에 있는 것보다 더 많은 항목을 얻으려고 하면 리스트 전체를 반환한다.
- `drop` 함수는 숫자와 리스트를 받아 리스트의 시작 부분부터 주어진 숫자까지의 항목을 버린다.
    - ex) `drop 3 [1, 2, 3, 4, 5] == [4, 5]`
- `maximum` 함수는 순서를 매길 수 있는 항목들의 리스트를 받아 가장 큰 항목을 반환한다.
    - ex) `maximum [1, 2, 3, 4, 5] == 5`
- `minimum` 함수는 순서를 매길 수 있는 항목들의 리스트를 받아 가장 작은 항목을 반환한다.
    - ex) `minimum [1, 2, 3, 4, 5] == 1`
- `sum` 함수는 숫자들의 리스트를 받아서 그들의 합을 반환한다.
    - ex) `sum [1, 2, 3, 4, 5] == 15`
- `product` 함수는 숫자들의 리스트를 받아서 그들의 곱을 반환한다.
    - ex) `product [1, 2, 3, 4, 5] == 120`
- `elem` 함수는 어떤 항목과 항목들의 리스트를 받아서 그 항목이 리스트의 항목인지를 검사한다.
    - ex) ``(3 `elem` [1, 2, 3, 4, 5]) == True``
- `replicate` 함수는 하나의 항목으로 구성된 리스트를 만드는 가장 쉬운 방법이다.
    - ex) `replicate 5 5 == [5, 5, 5, 5, 5]`
<br><br>


## 범위
- 범위는 열거될 수 있거나 순서대로 번호를 줄 수 있는 항목들로 구성된 리스트를 만든다.
- 구문 : `[${시작 값}..${종료 값}]`
    - ex) `[1..5] == [1, 2, 3, 4, 5]`
- 범위 안에 항목들 간의 간격을 지정할 수도 있다.
- 구문 : `[${첫 번째 값}, ${두 번째 값}..${종료 값}]`
    - ex) `[1, 3..9] == [1, 3, 5, 7, 9]`
    - 내림차순 리스트를 만들기 위해서는 간격 구문을 사용해서 만들어야 한다.
        - ex) `[5, 4..1] == [5, 4, 3, 2, 1]`
- 범위에서 종료 값을 지정하지 않으면 무한 리스트를 만들 수도 있다.
    - ex) `take 5 [1, 2..] == [1, 2, 3, 4, 5]`
    - 하스켈은 느긋한 언어이기 때문에 무한 리스트를 즉시 구하려고 하지 않는다.
- 무한 리스트를 만들기 위해 여러 함수들이 사용된다.
    - `cycle` 함수는 리스트를 받아서 항목들은 무한히 복제한다.
        - ex) `take 6 (cycle [1, 2, 3]) == [1, 2, 3, 1, 2, 3]`
    - `repeat` 함수는 항목을 받아서 그 항목으로만 무한 리스트를 만든다.
        - ex) `take 5 (repeat 5) == [5, 5, 5, 5, 5]`
<br><br>


## 리스트 통합
- 리스트 통합은 리스트를 검색하고 이동하며 결합하기 위한 방법이다.
- 리스트 통합은 수학의 `조건제시법`(set comprehensions) 개념과 매우 비슷하다.
- 구문 : `[${결과부} | ${제너레이터}]`
    - ex) `[x*2 | x <- [1..5]] == [2, 4, 6, 8, 10]`
    - 결과부는 결과 리스트에 반영될 항목들이 어떠해야 하는지를 지정한다.
    - 제너레이터는 각 항목과 결과 부의 변수를 바인딩한다.
    - 제너레이터는 콤마로 구분한다면 원하는 만큼 포함시킬 수 있다.
        - ex) `[x*y | x <- [1..2], y <- [1..3]] == [1, 2, 3, 2, 4, 6]`
        - 첫 제너레이터의 항목을 하나씩 가져온 후 이후 제너레이터에 대한 결과를 순차적으로 추가한다. 
- 통합 작업에 서술부를 추가할 수도 있다.
    - 구문 : `[${결과부} | ${제너레이터}, ${서술부}]`
    - ex) `[x*2 | x <- [1..10], x*2 <= 10] == [2, 4, 6, 8, 10]`
    - 서술부는 리스트 통합 작업에 조건을 지정한다.
    - 서술부를 이용해서 리스트의 일부를 없애는 것을 `필터링`이라고도 한다.
    - 서술부는 콤마로 구분한다면 원하는 만큼 포함시킬 수 있다.
        - ex) `[x | x <- [1..7], x /= 6, x /= 7] == [1, 2, 3, 4, 5]`
- `length` 함수를 직접 만들기 위해 리스트 결합을 사용할 수도 있다.
    - 결과 : `length' xs = sum [1 | _ <- xs]`
        - 입력 리스트에서 가져온 항목을 사용하지 않으려면 임시 변수로 밑줄(_)을 사용할 수 있다.
- 중첩 리스트를 위해 중첩 리스트 결합을 사용할 수도 있다.
    - ex) `[ [x | x <- xs, even x] | xs <- xxs ]`
- 리스트 결합에 대한 가독성을 높이기 위해 여러 줄로 나눠서 작성할 수도 있다.
<br><br>


## 튜플
- 튜플은 여러 종류의 항목들을 하나의 값처럼 저장하는데 사용된다.
- 튜플은 여러가지 서로 다른 타입의 요소들을 단 하나의 튜플에 저장할 수 있다.
- 튜플은 고정된 크기를 가진다.
- 튜플은 괄호로 둘러 쌓이며, 요소들은 콤마로 구분된다.
- ex) `(3, 'a', "hello")`
- 크기가 2인 튜플은 `페어`(pair)라고 부르고 크기가 3인 튜플은 `트리플`(triple)이라고 부른다.
- 데이터 타입이 모두 같고 동일한 길이를 가져야 동일한 튜플의 타입으로 구분된다. 
- 튜플은 비교될 수 있는 요소를 가지고 있다면 동일 타입의 튜플끼리 비교가 가능하다.
- 단일 리스트는 있지만 단일 튜플은 존재하지 않는다.

### 페어 이용하기
- `fst` 함수는 페어를 받아서 첫 번째 요소를 반환한다.
    - ex) `fst (1, 2) == 1`
- `snd` 함수는 페어를 받아서 두 번째 요소를 반환한다.
    - ex) `snd (1, 2) == 2`
- `zip` 함수는 두 개의 리스트를 받아서 매칭되는 요소를 페어로 결합한 후 리스트로 만든다.
    - ex) `zip [1, 2, 3] [4, 5, 6] == [(1, 4), (2, 5), (3, 6)]`
    - 서로 길이가 다른 리스트를 인자로 주면 짧은 리스트에 맞춰서 결과가 반환된다.

### 직각 삼각형 찾기
- 찾고자 하는 직각 삼각형의 조건
    - 세 변의 길이는 모두 정수이다.
    - 각 변의 길이는 10보다 작거나 같다.
    - 삼각형의 둘레(변의 길이의 합)는 24이다.
- 결과 : `[ (a, b, c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c == 24]`
<br><br>


# 타입

## 명시적 타입 선언
- `::` 연산자는 `~ 타입을 갖는다`라고 읽는다.
- 명시적 타입은 항상 첫 번째 문자가 대문자이다.
- 함수도 타입을 가지며, 함수를 정의할 때 명시적 타입 선언을 할 수 있다.
    - ex) `removeNonUppercase :: [Char] -> [Char]`
- 여러 개의 매개변수를 받는 함수의 타입은 `->` 키워드를 이용해 나열한다.
    - ex) `addThree :: Int -> Int -> Int -> Int`
- `->` 키워드는 일반적으로 `오른쪽-연관`(right-associative)이므로 오른쪽에서 왼쪽으로 처리한다.
- 명시적 타입 선언 시 매개변수와 반환값의 타입은 `->` 키워드로 구분된다.
    - 여기서 반환 타입은 항상 선언문의 마지막에 와야 한다.
<br><br>


## 일반적인 하스켈 타입
- `Int`는 정수(integer)의 약자이며, 숫자를 위해 사용된다.
    - `Int`는 범위가 있으므로 최솟값과 최댓값이 존재한다.
    - `GHC` 컴파일러에서는 `Int`의 범위가 컴퓨터의 기계어 크기로 정해진다.
- `Integer`는 한계가 없는 정수를 저장하는데 사용된다.
    - 하지만, `Int`가 더 효율적으로 동작한다.
- `Float`는 하나의 소수점을 가진 부동소수점수이다.
- `Double`은 정밀도가 두 배인 부동소수점수이다.
    - 두 배의 정밀도 숫자를 나타내기 위해 두 배의 비트를 사용한다.
- `Bool`은 불리언 타입이며, `True`와 `False`의 값 두 개만 가질 수 있다.
- `Char`은 유니코드 문자를 나타내며, 홑 따옴표(')로 표시된다.
- `String`은 문자열을 나타내며, `[Char]`과 동일하게 사용된다.
- 튜플(Tuple)도 타입이지만, 요소들의 길이 뿐만 아니라 타입에 따라 정의된다.
    - 이론적으로 튜플의 타입은 무한하다. (실제로 튜플은 최대 62개의 요소를 가질 수 있다.)
    - 비어있는 튜플 `()`도 타입으로 정의되며, 단 하나의 값만 가질 수 있다.
<br><br>


## 타입 변수
- 하스켈에서 타입의 이름은 대문자로 시작한다.
- 타입 변수(type variable)는 함수가 타입-안전(type-safe) 방식으로 다양한 타입들의 값에서 동작할 수 있도록 해준다.
    - ex) `head :: [a] -> a`
- 타입 변수는 다른 프로그래밍 언어들에 있는 제네릭(generic)과 많이 비슷하다.
- 타입 변수를 사용하는 함수를 다형 함수(polymorphic function)라고 부른다.
<br><br>


## 타입 클래스 101
- 타입 클래스(type class)는 어떤 동작을 정의하는 인터페이스이다.
- 특정 타입이 타입 클래스의 인스턴스라면 그것은 타입 클래스가 기술한 동작을 지원하며 구현된다.
    - ex) 항등 연산자(`==`)를 정의하는 타입 클래스 `Eq`
        - 타입 서명 :  `(==) :: (Eq a) => a -> a -> Bool`
- 타입 서명에서 `=>` 키워드는 `클래스 제약`(class constraint)을 명시해준다.

### Eq 타입 클래스
- `Eq` 타입 클래스는 타입의 값이 같은지를 검사하는데 사용된다.
- 이 인스턴스를 구현하는 함수는 `==`과 `/=`이다.

### Ord 타입 클래스
- `Ord` 타입 클래스는 타입의 값들을 특정 순서로 놓을 수 있도록 해준다.
- 이 인스턴스를 구현하는 함수는 `>`, `>=`, `<`, `<=`이다.

### Show 타입 클래스
- `Show` 타입 클래스는 타입의 값을 문자열처럼 표시할 수 있도록 해준다.
- `show` 함수를 통해 `Show` 타입 클래스의 인스턴스를 문자열처럼 출력할 수 있다.
    - ex) `show 5 == "5"`

### Read 타입 클래스
- `Read` 타입 클래스는 `Show` 타입 클래스와 반대로 문자열을 타입의 값으로 변경할 수 있도록 해준다.
- `read` 함수를 통해 문자열을 `Read` 타입 클래스의 인스턴스로 변경할 수 있다.
    - ex) `read "True" == True`
    - `read` 함수로 `Read`의 인스턴스인 값을 받을 때, 타입을 특정할 수 없는 경우에는 타입 어노테이션(type annotation)을 사용한다.
        - 타입 어노테이션은 표현식의 타입이 무엇인지 명시적으로 알려주는 방법이다.
        - 표현식의 끝에 `::` 키워드를 추가한 다음에 타입을 지정하면 된다.
        - ex) `(read "5" :: Int) == 5`

### Enum 타입 클래스
- `Enum` 타입 클래스는 연속적으로 순서가 있는 타입을 정의할 수 있도록 해준다.
- 이 인스턴스는 값들을 열거할 수 있고, 리스트의 범위 안의 값들을 사용할 수 있다.
- 또한 `succ` 함수와 `pred` 함수로 얻을 수 있는 다음 항목(successor)과 이전 항목(predecessor)도 정의되어 있다.
    - ex) `['a'..'e'] == ['a', 'b', 'c', 'd', 'e']`

### Bounded 타입 클래스
- `Bounded` 타입 클래스는 상한계와 하한계를 가질 수 있도록 해준다.
- 이 인스턴스는 `minBound` 함수와 `maxBound` 함수를 이용하여 상한계와 하한계를 확인할 수 있다.
    - ex) `(minBound :: Bool) == False`
    - `minBound` 함수와 `maxBound` 함수는 매개변수가 없기 때문에 다형성 상수(polymorphic constant)라고도 불린다.
- 구성 요소가 모두 `Bounded`의 인스턴스인 튜플은 그 역시 `Bounded`의 인스턴스로 간주된다.
    - ex) `(maxBound :: (Bool, Char)) == (True,'\1114111')`

### Num 타입 클래스
- `Num` 타입 클래스는 숫자처럼 동작할 수 있도록 해준다.
- ex) `20 :: (Num t) => t`
- `Num` 타입 클래스를 구현한 타입 : `Int`, `Integer`, `Float`, `Double`
- `Num` 타입 클래스의 인스턴스가 되려면 타입은 이미 `Show`와 `Eq` 타입 클래스을 구현해야 한다.

### Floating 타입 클래스
- `Floating` 타입 클래스는 부동소수점수를 저장할 수 있도록 해준다.
- `Floating` 타입 클래스를 구현한 타입 : `Float`, `Double`

### Integral 타입 클래스
- `Integral` 타입 클래스는 정수처럼 동작할 수 있도록 해준다.
- 비슷해보이는 `Num` 타입 클래스는 실수를 포함한 모든 숫자를 포함한다.
- `Integral` 타입 클래스를 구현한 타입 : `Int`, `Integer`
- 정수를 처리하는데 특히 유용한 함수 중 하나는 `fromIntegral` 함수이다.
    - 타입 서명 : `fromIntegral :: (Integral a, Num b) => a -> b`
    - `Int` 타입과 부동소수점수를 연산할 때 `fromIntegral` 함수를 통해 `Int` 타입을 좀 더 일반적인 숫자로 바꿔야 한다.
<br><br>


## 타입 클래스에 대한 마지막 정리
- 타입 클래스는 추상 인터페이스를 정의하기 때문에 하나의 타입이 여러 타입 클래스들의 인스턴스가 될 수 있다.
- 또한 하나의 타입 클래스는 여러 가지 타입들을 인스턴스처럼 가질 수 있다.
- 어떤 타입은 특정 타입 클래스의 인스턴스가 되기 위해 반드시 다른 타입 클래스의 인스턴스이어야 한다. (`전제조건`)
    - ex) `Ord` 타입 클래스의 인스턴스가 되기 위해서는 `Eq` 타입 클래스의 인스턴스가 먼저 되어야 한다.
<br><br>


# 함수의 구문

## 패턴 매칭
- 패턴 매칭(pattern matching)은 어떤 데이터가 따라야 할 패턴을 지정하거나, 그 패턴에 따라 데이터를 분해하기 위해 사용된다.
- 함수를 정의할 경우 다른 패턴에 대해 별도의 함수 내용을 만들 수 있다.
- 함수를 정의할 때 패턴 매칭을 사용하면 패턴들을 호출 시에 위부터 아래까지 검사된다.
- 패턴 안에 소문자로 시작하는 이름을 사용한다면 포괄적인 패턴처럼 동작하게 된다.
- ex) 재귀적으로 동작하는 팩토리얼 함수 `factorial` 정의 -> 
    ```haskell
    factorial :: Int -> Int
    factorial 0 = 1
    factorial n = n * factorial (n - 1)
    ```
- 포괄적인 패턴이 없고 다른 패턴들에 매칭되지 않는다면 패턴 매칭은 실패할 수 있다.
    - `Non-exhaustive patterns`라는 경고문과 함께 에러를 뱉는다.
    - 따라서 패턴 매칭을 활용할 때는 항상 끝에 포괄적인 패턴을 추가하는게 좋다.

### 튜플의 패턴 매칭
- 패턴 매칭은 튜플에서도 이용될 수 있다.
- ex) 두 개의 벡터를 받아서 그것들을 서로 더하는 함수 `addVectors` 정의 ->
    ```haskell
    addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
    addVectors (x1, y1) (x2, y2) = (x1+x2, y1+y2)
    ```

### 리스트의 패턴 매칭
- 패턴 매칭은 리스트에서도 이용될 수 있다.
- 리스트를 받는 패턴에 `x:xs`와 같이 정의하면 리스트의 헤더를 `x`에, 그리고 리스트의 나머지를 `xs`에 바인딩하게 된다.
    - ex) `head` 함수에 대한 재정의 ->
        ```haskell
        head' :: [a] -> a
        head' [] = error "Can't call head on an empty list, dummy!"
        head' (x:_) = x
        ```
    - `:` 문자를 포함하는 패턴은 하나 이상의 길이인 리스트에 대해서만 매칭된다.
    - 어떤 것을 몇 가지 변수들에 바인딩하기 위해서는 그것들을 괄호로 묶어줘야 한다.
    - `error` 함수는 문자열을 인자로 받아서 그 문자열을 이용한 런타임 에러를 발생시킨다.
- 신택틱 슈거(syntactic sugar)를 이용해 패턴에서 `(x:y:[])`는 `[x, y]`와 같이 사용할 수 있다.

### as-패턴
- as-패턴은 전체 원본 항목에 대한 참조는 유지하면서 패턴에 따라 항목을 분해할 수 있게 해준다.
- as-패턴을 만들기 위해서는 이름과 `@`문자를 일반적인 패턴 앞에 둔다.
- ex) `all@(x:xs)` as-패턴을 이용한 `firstLetter` 함수 정의 ->
    ```haskell
    firstLetter :: String -> String
    firstLetter "" = "Empty string, whoops!"
    firstLetter all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
    ```
- 위 패턴은 `all@(x:xs)`와 같은 리스트에 정확하게 일치하며, `all`를 이용해 더 쉽게 접근할 수 있도록 해준다.
<br><br>


## 가드
- 가드(guard)는 함수에 전달된 값들의 속성이 참인지 거짓인지를 검사하여 분기할 때 사용한다.
- 가드는 if 표현식과 매우 비슷하게 동작하지만, 가독성이 더 좋고 패턴과 잘 동작한다.
- ex) BMI(신체 용적 지수)에 따른 체중 결과를 반환하는 `bmiTell` 함수 정의 ->
    ```haskell
    bmiTell :: Double -> String
    bmiTell bmi
        | bmi <= 18.5 = "You're underweight!"
        | bmi <= 25.0 = "You're supposedly normal."
        | bmi <= 30.0 = "You're fat!"
        | otherwise   = "You're a whale."
    ```
- 가드는 파이프(`|`) 문자 다음에 논리식이 나오고, 논리식이 참일 경우에 사용될 함수의 내용이 그 다음에 나오게 된다.
- 가드의 논리식이 거짓일 경우에는 다음의 가드로 내려가서 검사를 반복하게 된다.
- 가드를 사용하기 위해서는 한 칸 이상의 들여쓰기가 필요하다.
- 가드의 `otherwise` 키워드는 이전 가드들의 조건에 맞지 않은 모든 것을 잡는다.
<br><br>


## where
- `where` 키워드는 함수의 중간 계산 결과를 저장하기 위해 사용한다.
- ex) BMI에 따른 체중 결과를 반환하는 `bmiTell` 함수의 `where` 절을 이용한 정의 ->
    ```haskell
    bmiTell :: Double -> Double -> String
    bmiTell weight height
        | bmi <= skinny = "You're underweight!"
        | bmi <= normal = "You're supposedly normal."
        | bmi <= fat = "You're fat!"
        | otherwise   = "You're a whale."
        where bmi = weight / height ^ 2
              skinny = 18.5
              normal = 25.0
              fat = 30.0
    ```
- `where` 키워드를 이용해 하나 이상의 상수나 함수의 정의가 가능하다.
- `where` 절의 모든 상수명들은 들여 쓰기를 정렬해서 맞춰줘야 한다.

### 범위
- 함수의 `where` 절에 정의한 상수들은 그 함수에서만 보이기 때문에 다른 함수의 네임스페이스에 영향을 미치지 않는다.
- 또한 `where` 절의 바인딩은 서로 다른 패턴의 함수 내용에 걸쳐 공유되지 않는다.
    - 모든 패턴에 대해 바인딩하기 위해서는 해당 상수나 함수를 전역으로 정의해야 한다.

### where와 함께하는 패턴 매칭
- 패턴 매칭을 이용한 `where` 절의 바인딩도 사용할 수 있다.
- ex) 이름과 성을 받아서 이니셜을 반환하는 `initials` 함수 정의 ->
    ```haskell
    initials :: String -> String -> String
    initials firstname lastname = [f] ++ ". " ++ [l] ++ "."
        where (f:_) = firstname
              (l:_) = lastname
    ```

### where 블록 속의 함수
- `where` 절 속에 상수를 정의했던 것처럼 함수를 정의할 수도 있다.
- ex) 몸무게와 키 페어의 리스트를 받아 BMI 리스트를 반환하는 `calcBmis` 함수 정의 ->
    ```haskell
    calcBmis :: [(Double, Double)] -> [Double]
    calcBmis xs = [bmi w h | (w, h) <- xs]
        where bmi weight height = weight / height ^ 2
    ```
<br><br>


## let
- `let` 표현식은 `where` 바인딩과 매우 비슷하다.
- `let` 표현식은 어디서든지 변수와 바인딩할 수 있게 해주며, 범위가 매우 작아서 가드에서도 보이지 않는다.
- `let` 표현식 또한 패턴 매칭에서 사용될 수 있다.
- ex) 실린더의 높이와 반지름으로 계산된 면적을 반환하는 `cylinder` 함수 정의 ->
    ```haskell
    cylinder :: Double -> Double -> Double
    cylinder r h =
        let sideArea = 2 * pi * r * h
            topArea = pi * r ^ 2
        in sideArea + 2 * topArea
    ```
- `let` 표현식과 `where` 바인딩과의 가장 큰 차이점은 `let`은 표현식이기 때문에 코드 어디서든 사용이 가능하다는 점이다.
    - ex) `4 * (let a = 9 in a + 1) + 2 == 42`
- `let` 표현식을 사용하기 위한 유용한 방법은 다음과 같다.
    - 로컬 영역의 함수를 실행하기 위해 사용된다.
        - ex) `[let square x = x * x in (square 1, square 2)] == [(1, 4)]`
    - 여러 가지 변수들을 바인딩하고자 할 때 세미콜론(`;`)으로 구분할 수 있다.
        - ex) `let a = 100; b = 200; c = 300 in a*b*c == 6000000`
    - 패턴 매칭을 이용하여 튜플의 요소들을 빠르게 해체하고 유용하게 사용할 수 있다.
        - ex) `(let (a, b, c) = (1, 2, 3) in a+b+c) * 100 == 600`
    - 리스트 통합에서 `let` 표현식을 사용할 수 있다.

### 리스트 통합에서의 let
- 리스트 통합에서 `let` 표현식은 서술부를 사용하는 것처럼 포함시킬 수 있다.
    - 구문 : `[${결과부} | ${제너레이터}, ${let 표현식}, ${서술부}]`
- ex) 몸무게와 키 페어의 리스트를 받아 BMI 리스트를 반환하는 `calcBmis` 함수의 `let` 표현식을 이용한 정의 ->
    ```haskell
    calcBmis :: [(Double, Double)] -> [Double]
    calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
    ```

### GHCi에서의 let
- 함수와 상수를 GHCi에서 `let` 표현식으로 직접 정의할 경우 바인딩의 `in` 부분은 생략될 수 있다.
    - `in` 부분 생략 시 해당 이름은 인터랙티브 세션 내내 보이게 된다.
- `in` 부분을 생략하지 않은 `let` 표현식은 그 자체로 표현식이며 값을 나타낸다.
<br><br>


## case 표현식
- `case` 표현식은 특정 변수의 특정 값에 대한 코드 블록을 실행할 수 있게 해준다.
- 구문 ->
    ```haskell
    case ${변수} of ${패턴1} -> ${결과1}
                   ${패턴2} -> ${결과2}
                   ${패턴3} -> ${결과3}
                   ...
    ```
- `case` 표현식은 `if else` 표현식과 `let` 표현식과 같은 표현식이다.
- 일반적으로 함수에 사용되는 종류의 패턴 매칭은 `case` 표현식에 대한 신택틱 슈거이다.
- ex) `head` 함수에 대한 `case` 표현식을 이용한 재정의 ->
    ```haskell
    head' :: [a] -> a
    head' xs = case xs of [] -> error "Can't call head on an empty list!"
                          (x:_) -> x
    ```
- 함수의 패턴 매칭은 정의된 함수일 경우에만 사용할 수 있지만, `case` 표현식은 어디서든 사용할 수 있다.
<br><br>


# 재귀

## 재귀함수
- 재귀는 함수의 정의 안에 적용되는 함수를 정의하는 방법이다.
- 이러한 재귀 함수는 자기 자신을 호출한다.
- 재귀적으로 정의된 함수의 전략은 어떤 문제를 동일한 종류의 더 작은 문제로 나누고 그 작은 문제를 해결하는 것이다.
- 함수형 언어에서는 `어떻게` 계산할지를 지정하는 것이 아니라, 그것이 `무엇인지`를 선언해 계산을 수행하므로 재귀는 중요하다.
<br><br>


## Maximum
- `maximum` 함수는 순서(`Ord` 타입 클래스의 인스턴스)를 둘 수 있는 리스트를 받아서 가장 큰 값을 반환한다.
- 결과 ->
    ```haskell
    maximum' :: (Ord a) => [a] -> a
    maximum' [] = error "maximum of empty list!"
    maximum' [x] = x
    maximum' (x:xs) = max x (maximum' xs)
    ```
<br><br>


## 몇 가지 재귀함수들
- 이미 하스켈에 존재하는 함수들이지만, 재귀를 설계하는 감각을 익히기 위해 직접 구현을 해봐야 한다.

### replicate
- `Int` 값와 항목의 값을 받아서 해당 항목을 몇 번 반복한 리스트를 반환하는 함수이다.
- 결과 ->
    ```haskell
    replicate' :: Int -> a -> [a]
    replicate' n x
        | n <= 0    = []
        | otherwise = x : replicate' (n - 1) x
    ```

### take
- `Int` 값과 리스트를 받아 리스트에서 지정된 개수의 요소를 반환하는 함수이다.
- 결과 ->
    ```haskell
    take' :: Int -> [a] -> [a]
    take' n _
        | n <= 0   = []
    take' _ []     = []
    take' n (x:xs) = x : take' (n - 1) xs
    ```

### reverse
- 리스트를 받아서 요소들의 순서가 역순으로 구성된 리스트를 반환하는 함수이다.
- 결과 ->
    ```haskell
    reverse' :: [a] -> [a]
    reverse' [] = []
    reverse' (x:xs) = reverse' xs ++ [x]
    ```

### repeat
- 요소를 받아서 그 요소로 구성된 무한 리스트를 반환하는 함수이다.
- 결과 ->
    ```haskell
    repeat' :: a -> [a]
    repeat' x = x : repeat' x
    ```

### zip
- 리스트 두 개를 받아서 페어로 결합한 리스트를 반환하는 함수이다.
- 결과 ->
    ```haskell
    zip' :: [a] -> [b] -> [(a, b)]
    zip' _ [] = []
    zip' [] _ = []
    zip' (x:xs) (y:ys) = (x, y) : zip' xs ys
    ```

### elem
- 동등 비교가 가능한 값(`Eq` 타입 클래스의 인스턴스)과 리스트를 받아서 그 값이 리스트의 멤버인지를 검사하는 함수이다.
- 결과 -> 
    ```haskell
    elem' :: (Eq a) => a -> [a] -> Bool
    elem' a [] = False
    elem' a (x:xs)
        | a == x    = True
        | otherwise = a `elem'` xs 
    ```
<br><br>


## 정렬
- 순서가 있는 요소를 가진 리스트를 정렬하는 문제는 보통 재귀적인 해결책을 갖는다.
- 정렬 알고리즘 중에서 `퀵소트`(quicksort)를 이용한 정렬 함수를 구현해 볼 것이다.
- 결과 -> 
    ```haskell
    quicksort :: (Ord a) => [a] -> [a]
    quicksort [] = []
    quicksort (x:xs) =
        let smallerOrEqual = [a | a <- xs, a <= x]
            larger = [a | a <- xs, a > x]
        in quicksort smallerOrEqual ++ [x] ++ quicksort larger
    ```
<br><br>


## 재귀적으로 생각하기
- 재귀를 설계할 때에는 가장 평범한 입력이 들어올 때의 간단하고 재귀적이지 않은 베이스 케이스를 정의하면서 시작해야 한다.
- 그런 다음 문제를 하나 이상의 작은 문제로 나누고 동일한 함수를 적용해 재귀적으로 그 문제들을 해결한다.
- 마지막으로 해결된 작은 문제들로 최종 해결책을 만든다.
<br><br>


# 고차원 함수

## 커리된 함수
- 하스켈의 모든 함수는 공식적으로 하나의 매개션부만 받으며, 여러 매개변수를 받았던 모든 함수들은 커리된 함수(curried function)이다.
- 커리된 함수는 여러 매개변수를 받는 대신 항상 정확히 하나의 매개변수를 받는 함수이다.
    - 하나의 매개변수를 가지고 함수가 호출되면 다음 매개변수를 받는 함수를 반환하게 된다.
    - ex) `max 4 5 == (max 4) 5`
- 커리된 함수를 이용하면 남겨둔 만큼의 매개변수를 받는 `부분적으로 적용된` 함수를 사용할 수 있다.
    - 즉석으로 부분적인 함수를 생성해낼 수 있다.

### 섹션
- 섹션(section)은 중위 연산자에 인자를 부분적으로 적용하는 것을 의미한다.
- 중위 함수에 섹션을 사용하기 위해서는 소괄호로 식을 감싸고 한쪽에만 매개변수를 제공하면 된다.
- ex) 섹션을 이용해 10으로 나눈 결과를 반환하는 `divideByTen` 함수 정의 ->
    ```haskell
    divideByTen :: (Floating a) => a -> a
    divideByTen = (/ 10)
    ```
- ex) 섹션을 이용해 문자가 영어 대문자인지 검사하는 `isUpperAlpha` 함수 정의 ->
    ```haskell
    isUpperAlpha :: Char -> Bool
    isUpperAlpha = (`elem` ['A'..'Z'])
    ```
- `-` 연산자의 경우는 빼기 함수 뿐만 아니라 음수를 표현할 때에도 이용되므로 빼기 함수에 섹션을 사용하고 싶다면 `subtract` 함수를 이용해야 한다.
<br><br>


## 잘 정리된 고차원주의
- 하스켈에서 함수는 일급 객체(first-class citizen)이므로 매개변수나 반환값으로 함수를 넘길 수 있다.
- ex) 특정 함수를 두 번 적용시키는 `applyTwice` 함수 정의 ->
    ```haskell
    applyTwice :: (a -> a) -> a -> a
    applyTwice f x = f (f x)
    ```
    - 첫 번째 매개변수로 함수를 받아 두 번째 매개변수로 들어온 값에 두 번 적용시킨다.
    - 사용 : `applyTwice (+ 3) 10 == 16`

### zipWith 구현하기
- `zipWith` 함수는 특정 함수와 두 개의 리스트를 매개변수로 받아서 해당 요소들 간에 함수를 적용시켜 두 리스트를 결합한다.
- 결과 -> 
    ```haskell
    zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
    zipWith' _ [] _ = []
    zipWith' _ _ [] = []
    zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
    ```
- 사용 : `zipWith' (+) [4, 2, 7, 5] [2, 5, 1, 4] == [6, 7, 8, 9]`

### flip 구현하기
- `flip` 함수는 함수를 받아서 원본 함수와 비슷하지만 매개 변수의 순서가 뒤바뀐 함수를 반환한다.
- 결과 ->
    ```haskell
    flip' :: (a -> b -> c) -> (b -> a -> c)
    flip' f = g
        where g x y = f y x
    ```
    - 위의 구현은 좀 더 간단하게 다음과 같이 축약도 가능하다.
    - 축약 : `flip' f x y = f y x`
- 사용 : `flip' zip [1, 2, 3] "abc" == [('a', 1), ('b', 2), ('c', 3)]`
<br><br>


## 함수형 프로그래머의 도구상자
- 하스켈에는 여러 값들을 가지고 작업하는데 도움을 줄 수 있는 유용함 함수들이 있다.

### map 함수
- `map` 함수는 함수와 리스트를 받아서 새로운 리스트를 생성하기 위해 리스트에 있는 모든 요소에 인자로 넘어온 함수를 적용한다.
- 구현 -> 
    ```haskell
    map :: (a -> b) -> [a] -> [b]
    map _ [] = []
    map f (x:xs) = f x : map f xs
    ```
- 사용 : `map (map (^2)) [[1, 2], [3, 4]] == [[1, 4], [9, 16]]`
- `map` 함수를 사용하는 구문은 리스트 통합을 사용하는 구문으로 변경할 수 있다.
    - ex) `map (+ 3) [1..3] == [x+3 | x <- [1..3]]`

### filter 함수
- `filter` 함수는 조건과 리스트를 받아서 그 조건에 만족하는 요소들의 리스트를 반환한다.
    - 여기서 `조건`(predicate)은 어떤 것이 참인지 거짓인지를 알려주는 함수라는 것을 기억해야 한다.
- 구현 -> 
    ```haskell
    filter :: (a -> Bool) -> [a] -> [a]
    filter _ [] = []
    filter p (x:xs)
        | p x       = x : filter p xs
        | otherwise = filter p xs
    ```
- 사용 : `filter even [1..10] == [2, 4, 6, 8, 10]`
- `filter` 함수를 사용하는 구문은 리스트 통합을 사용하는 구문으로 변경할 수 있다.
    - ex) `filter (< 5) (filter even [1..10]) == [x | x <- [1..10], x < 5, even x]`

### 여러 매개변수와 함수 매핑하기
- 여러 매개변수를 받는 함수를 매핑하는 것도 가능하다.
- 두 개의 매개변수를 받는 함수에 단 하나의 매개변수만 주는 것은 하나의 매개변수를 받는 함수를 반환하게 된다. (커리된 함수)
- ex) `((map (*) [0..3]) !! 2) 5 == 10`
<br><br>


## 람다
- `람다`(lambda)는 단 한 번만 함수가 필요할 때 사용하는 익명의 함수이다.
- 구문 : `(\${매개변수들} -> ${함수 내용})`
- 일반적으로는 고차원 함수에 전달하는 하나의 목적으로 람다를 만들게 된다.
- 람다는 표현식이기 때문에 함수의 매개변수로 전달할 수 있다.
    - ex) `map (\x -> x ^ 2) [1..3] == [1, 4, 9]`
- 람다는 일반적인 함수처럼 패턴 매칭을 할 수 있다.
    - ex) `map (\(a, b) -> a + b) [(1, 2), (3, 4), (5, 6)] == [3, 7, 11]`
    - 하지만 하나의 매개 변수에 대해 여러 개의 패턴을 정의할 수는 없다.
<br><br>


