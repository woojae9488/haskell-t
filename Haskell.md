# 시작하기

## 준비사항
- 사용할 하스켈 컴파일러 : `GHC` (Glasgow Haskell Compiler)
    - 하스켈 스크립트(`.hs` 확장자를 가진 스크립트) 컴파일 가능
    - 인터랙티브 모드(`GHCi`)도 제공 (`ghci` 명령어를 통해 실행)
- 하스켈 플랫폼 다운로드 : https://www.haskell.org/downloads/

### GHCi 프로그램의 명령어
- `:t ${expression}` : 표현식의 타입을 확인
- `:l ${haskell script}` : 하스켈 스크립트 불러오기 (load)
- `:r` : 하스켈 스크립트 다시 불러오기 (reload)
- `:q` : GHCi 프로그램 종료 (quit)
- `:! ${cmd}` : shell에서 cmd 명령어 실행
- `:set prompt "${prompt format}"` : GHCi 프로그램의 프롬프트 형식 변경

### GHCi 프로그램의 기본 설정 변경
- GHCi 프로그램을 실행하는 홈 디렉터리에 `.ghci`라는 파일을 만든 후 명령어 추가
- 기본적으로 `:set prompt` 명령을 통해 프롬프트 형식을 변경한다.
<br><br>


## 함수 호출하기
- 중위 함수(infix function) : 함수명이 매개변수 2개 사이에 오는 함수
    - 기본적인 연산자들이 중위 함수로 작동한다.
- 전위 함수(prefix function) : 함수명이 매개변수들 앞에 오는 함수
    - 대부분의 함수들은 전위 함수로 작동한다.
    - 2개의 매개변수를 받는 전위 함수는 역 따옴표(`)로 함수명을 감싸면 중위 함수처럼 사용할 수 있다.
        - ex) `div 50 10`은 ``50 `div` 10``과 동일하다.
- 함수명은 대문자로 시작할 수 없으며, 어퍼스트로피(')는 함수명으로 유요한 문자이다.
- 함수명 끝에 어퍼스트로피를 붙이면 비슷한 이름을 가진 함수의 약간 다른 버전을 의미한다.
- 특정 함수가 특수 문자만으로 구성되어 있다면 기본적으로 중위 함수로 간주된다.
    - 중위 함수의 타입 서명을 보고 싶거나, 전위 함수처럼 호출하고 싶다면 소괄호(`()`)로 감싸줘야 한다.
<br><br>


## 조건문 if 문
- 구문 : `if ${조건식} then ${참 값} else ${거짓 값}`
- 하스켈에서는 if 문에서 else 부분이 필수적이다.
- 하스켈의 if 문은 값을 반환해야 하는 표현식으로 동작한다.
<br><br>


## 리스트 소개
- 리스트는 같은 종류의 데이터 구조이다. (동일한 타입의 여러 항목들을 가지고 있다.)
- 리스트는 대괄호로 둘러 쌓이며, 리스트의 값은 콤마로 구분된다.
    - ex) `myList = [1, 2, 3, 4, 5]`
- 하스켈에서 문자열은 문자들의 리스트와 동일하다.
    - ex) `"hello" == ['h', 'e', 'l', 'l', 'o']`

### 리스트 연결
- `++` 연산자를 사용하여 리스트 2개를 연결할 수 있다.
    - ex) `[1, 2, 3] ++ [4, 5, 6] == [1, 2, 3, 4, 5, 6]`
- 긴 문자열에서 `++` 연산자를 반복적으로 사용하는 것은 지양해야 한다.
    - `++` 연산자는 첫 번째 리스트 전체를 읽어들여야 하기 때문이다.
- `:` 연산자(cons 연산자)를 사용하여 리스트의 시작 부분에 항목을 추가할 수 있다.
    - ex) `1:[2, 3, 4, 5] == [1, 2, 3, 4, 5]`
    - `:` 연산자는 리스트 전체를 읽어들이지 않고 즉각적으로 항목이 추가된다.

### 리스트 항목에 접근하기
- `!!` 연산자를 사용하면 리스트 항목을 인덱스로 접근할 수 있다.
    - ex) `[1, 2, 3, 4, 5] !! 0 == 1`

### 리스트 안의 리스트
- 리스트는 리스트를 항목으로 가질 수 있으며, 리스트를 항목으로 가진 리스트를 가질 수 있다.
    - ex) `matrix = [[1, 2], [3, 4], [5, 6]]`
- 리스트에 있는 리스트의 길이는 다를 수 있지만, 타입은 같아야 한다.

### 리스트 비교하기
- 리스트가 담고 있는 항목이 비교될 수 있다면 리스트도 비교될 수 있다.
- 2개의 리스트를 비교하기 위해 `<`, `<=`, `>`, `>=` 연산자를 사용하면 사전적 순서로 비교하게 된다.
    - 첫 번째 항목부터 시작해서 다음 항목들을 순차적으로 비교한다.
- 비어있지 않은 리스트는 비어있는 리스트보다 항상 크다고 간주된다.

### 더 많은 리스트 연산
- `head` 함수는 리스트를 받아서 첫 번째 항목을 반환한다.
    - ex) `head [1, 2, 3, 4, 5] == 1`
- `tail` 함수는 리스트를 받아서 첫 번째 항목을 제외한 나머지를 반환한다.
    - ex) `tail [1, 2, 3, 4, 5] == [2, 3, 4, 5]`
- `last` 함수는 리스트를 받아서 제일 마지막 항목을 반환한다.
    - ex) `last [1, 2, 3, 4, 5] == 5`
- `init` 함수는 리스트를 받아서 제일 마지막 항목을 제외한 나머지를 반환한다.
    - ex) `init [1, 2, 3, 4, 5] == [1, 2, 3, 4]`
- 위 4개의 함수들은 비어있는 리스트가 인자로 전달 시 에러가 던져진다.
- `length` 함수는 리스트를 받아서 그 길이를 반환한다.
    - ex) `length [1, 2, 3, 4, 5] == 5`
- `null` 함수는 리스트가 비어있는지 검사한다.
    - ex) `null [1, 2, 3, 4, 5] == False`
- `reverse` 함수는 리스트를 역순으로 만든다.
    - ex) `reverse [1, 2, 3, 4, 5] == [5, 4, 3, 2, 1]`
- `take` 함수는 숫자와 리스트를 받아 리스트의 시작 부분부터 주어진 숫자까지의 항목을 추출한다.
    - ex) `take 3 [1, 2, 3, 4, 5] == [1, 2, 3]`
    - 리스트에 있는 것보다 더 많은 항목을 얻으려고 하면 리스트 전체를 반환한다.
- `drop` 함수는 숫자와 리스트를 받아 리스트의 시작 부분부터 주어진 숫자까지의 항목을 버린다.
    - ex) `drop 3 [1, 2, 3, 4, 5] == [4, 5]`
- `maximum` 함수는 순서를 매길 수 있는 항목들의 리스트를 받아 가장 큰 항목을 반환한다.
    - ex) `maximum [1, 2, 3, 4, 5] == 5`
- `minimum` 함수는 순서를 매길 수 있는 항목들의 리스트를 받아 가장 작은 항목을 반환한다.
    - ex) `minimum [1, 2, 3, 4, 5] == 1`
- `sum` 함수는 숫자들의 리스트를 받아서 그들의 합을 반환한다.
    - ex) `sum [1, 2, 3, 4, 5] == 15`
- `product` 함수는 숫자들의 리스트를 받아서 그들의 곱을 반환한다.
    - ex) `product [1, 2, 3, 4, 5] == 120`
- `elem` 함수는 어떤 항목과 항목들의 리스트를 받아서 그 항목이 리스트의 항목인지를 검사한다.
    - ex) ``(3 `elem` [1, 2, 3, 4, 5]) == True``
- `replicate` 함수는 하나의 항목으로 구성된 리스트를 만드는 가장 쉬운 방법이다.
    - ex) `replicate 5 5 == [5, 5, 5, 5, 5]`
<br><br>


## 범위
- 범위는 열거될 수 있거나 순서대로 번호를 줄 수 있는 항목들로 구성된 리스트를 만든다.
- 구문 : `[${시작 값}..${종료 값}]`
    - ex) `[1..5] == [1, 2, 3, 4, 5]`
- 범위 안에 항목들 간의 간격을 지정할 수도 있다.
- 구문 : `[${첫 번째 값}, ${두 번째 값}..${종료 값}]`
    - ex) `[1, 3..9] == [1, 3, 5, 7, 9]`
    - 내림차순 리스트를 만들기 위해서는 간격 구문을 사용해서 만들어야 한다.
        - ex) `[5, 4..1] == [5, 4, 3, 2, 1]`
- 범위에서 종료 값을 지정하지 않으면 무한 리스트를 만들 수도 있다.
    - ex) `take 5 [1, 2..] == [1, 2, 3, 4, 5]`
    - 하스켈은 느긋한 언어이기 때문에 무한 리스트를 즉시 구하려고 하지 않는다.
- 무한 리스트를 만들기 위해 여러 함수들이 사용된다.
    - `cycle` 함수는 리스트를 받아서 항목들은 무한히 복제한다.
        - ex) `take 6 (cycle [1, 2, 3]) == [1, 2, 3, 1, 2, 3]`
    - `repeat` 함수는 항목을 받아서 그 항목으로만 무한 리스트를 만든다.
        - ex) `take 5 (repeat 5) == [5, 5, 5, 5, 5]`
<br><br>


## 리스트 통합
- 리스트 통합은 리스트를 검색하고 이동하며 결합하기 위한 방법이다.
- 리스트 통합은 수학의 `조건제시법`(set comprehensions) 개념과 매우 비슷하다.
- 구문 : `[${결과부} | ${항목부}]`
    - ex) `[x*2 | x <- [1..5]] == [2, 4, 6, 8, 10]`
    - 결과부는 결과 리스트에 반영될 항목들이 어떠해야 하는지를 지정한다.
    - 항목부는 각 항목과 결과 부의 변수를 바인딩한다.
    - 항목부는 콤마로 구분한다면 원하는 만큼 포함시킬 수 있다.
        - ex) `[x*y | x <- [1..2], y <- [1..3]] == [1, 2, 3, 2, 4, 6]`
        - 첫 항목부의 항목을 하나씩 가져온 후 이후 항목부에 대한 결과를 순차적으로 추가한다. 
- 통합 작업에 서술부를 추가할 수도 있다.
    - 구문 : `[${결과부} | ${항목부}, ${서술부}]`
    - ex) `[x*2 | x <- [1..10], x*2 <= 10] == [2, 4, 6, 8, 10]`
    - 서술부는 리스트 통합 작업에 조건을 지정한다.
    - 서술부를 이용해서 리스트의 일부를 없애는 것을 `필터링`이라고도 한다.
    - 서술부는 콤마로 구분한다면 원하는 만큼 포함시킬 수 있다.
        - ex) `[x | x <- [1..7], x /= 6, x /= 7] == [1, 2, 3, 4, 5]`
- `length` 함수를 직접 만들기 위해 리스트 결합을 사용할 수도 있다.
    - 결과 : `length' xs = sum [1 | _ <- xs]`
        - 입력 리스트에서 가져온 항목을 사용하지 않으려면 임시 변수로 밑줄(_)을 사용할 수 있다.
- 중첩 리스트를 위해 중첩 리스트 결합을 사용할 수도 있다.
    - ex) `[ [x | x <- xs, even x] | xs <- xxs ]`
- 리스트 결합에 대한 가독성을 높이기 위해 여러 줄로 나눠서 작성할 수도 있다.
<br><br>


## 튜플
- 튜플은 여러 종류의 항목들을 하나의 값처럼 저장하는데 사용된다.
- 튜플은 여러가지 서로 다른 타입의 요소들을 단 하나의 튜플에 저장할 수 있다.
- 튜플은 고정된 크기를 가진다.
- 튜플은 괄호로 둘러 쌓이며, 요소들은 콤마로 구분된다.
- ex) `(3, 'a', "hello")`
- 크기가 2인 튜플은 `페어`(pair)라고 부르고 크기가 3인 튜플은 `트리플`(triple)이라고 부른다.
- 데이터 타입이 모두 같고 동일한 길이를 가져야 동일한 튜플의 타입으로 구분된다. 
- 튜플은 비교될 수 있는 요소를 가지고 있다면 동일 타입의 튜플끼리 비교가 가능하다.
- 단일 리스트는 있지만 단일 튜플은 존재하지 않는다.

### 페어 이용하기
- `fst` 함수는 페어를 받아서 첫 번째 요소를 반환한다.
    - ex) `fst (1, 2) == 1`
- `snd` 함수는 페어를 받아서 두 번째 요소를 반환한다.
    - ex) `snd (1, 2) == 2`
- `zip` 함수는 두 개의 리스트를 받아서 매칭되는 요소를 페어로 결합한 후 리스트로 만든다.
    - ex) `zip [1, 2, 3] [4, 5, 6] == [(1, 4), (2, 5), (3, 6)]`
    - 서로 길이가 다른 리스트를 인자로 주면 짧은 리스트에 맞춰서 결과가 반환된다.

### 직각 삼각형 찾기
- 찾고자 하는 직각 삼각형의 조건
    - 세 변의 길이는 모두 정수이다.
    - 각 변의 길이는 10보다 작거나 같다.
    - 삼각형의 둘레(변의 길이의 합)는 24이다.
- 결과 : `[ (a, b, c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c == 24]`
<br><br>


# 타입

## 명시적 타입 선언
- `::` 연산자는 `~ 타입을 갖는다`라고 읽는다.
- 명시적 타입은 항상 첫 번째 문자가 대문자이다.
- 함수도 타입을 가지며, 함수를 정의할 때 명시적 타입 선언을 할 수 있다.
    - ex) `removeNonUppercase :: [Char] -> [Char]`
- 여러 개의 매개변수를 받는 함수의 타입은 `->` 키워드를 이용해 나열한다.
    - ex) `addThree :: Int -> Int -> Int -> Int`
- 명시적 타입 선언 시 매개변수와 반환값의 타입은 `->` 키워드로 구분된다.
    - 여기서 반환 타입은 항상 선언문의 마지막에 와야 한다.
<br><br>


## 일반적인 하스켈 타입
- `Int`는 정수(integer)의 약자이며, 숫자를 위해 사용된다.
    - `Int`는 범위가 있으므로 최솟값과 최댓값이 존재한다.
    - `GHC` 컴파일러에서는 `Int`의 범위가 컴퓨터의 기계어 크기로 정해진다.
- `Integer`는 한계가 없는 정수를 저장하는데 사용된다.
    - 하지만, `Int`가 더 효율적으로 동작한다.
- `Float`는 하나의 소수점을 가진 부동소수점수이다.
- `Double`은 정밀도가 두 배인 부동소수점수이다.
    - 두 배의 정밀도 숫자를 나타내기 위해 두 배의 비트를 사용한다.
- `Bool`은 불리언 타입이며, `True`와 `False`의 값 두 개만 가질 수 있다.
- `Char`은 유니코드 문자를 나타내며, 홑 따옴표(')로 표시된다.
- `String`은 문자열을 나타내며, `[Char]`과 동일하게 사용된다.
- 튜플(Tuple)도 타입이지만, 요소들의 길이 뿐만 아니라 타입에 따라 정의된다.
    - 이론적으로 튜플의 타입은 무한하다. (실제로 튜플은 최대 62개의 요소를 가질 수 있다.)
    - 비어있는 튜플 `()`도 타입으로 정의되며, 단 하나의 값만 가질 수 있다.
<br><br>


## 타입 변수
- 하스켈에서 타입의 이름은 대문자로 시작한다.
- 타입 변수(type variable)는 함수가 타입-안전(type-safe) 방식으로 다양한 타입들의 값에서 동작할 수 있도록 해준다.
    - ex) `head :: [a] -> a`
- 타입 변수는 다른 프로그래밍 언어들에 있는 제네릭(generic)과 많이 비슷하다.
- 타입 변수를 사용하는 함수를 다형 함수(polymorphic function)라고 부른다.
<br><br>


## 타입 클래스 101
- 타입 클래스(type class)는 어떤 동작을 정의하는 인터페이스이다.
- 특정 타입이 타입 클래스의 인스턴스라면 그것은 타입 클래스가 기술한 동작을 지원하며 구현된다.
    - ex) 항등 연산자(`==`)를 정의하는 타입 클래스 `Eq`
        - 타입 서명 :  `(==) :: (Eq a) => a -> a -> Bool`
- 타입 서명에서 `=>` 키워드는 `클래스 제약`(class constraint)을 명시해준다.

### Eq 타입 클래스
- `Eq` 타입 클래스는 타입의 값이 같은지를 검사하는데 사용된다.
- 이 인스턴스를 구현하는 함수는 `==`과 `/=`이다.

### Ord 타입 클래스
- `Ord` 타입 클래스는 타입의 값들을 특정 순서로 놓을 수 있도록 해준다.
- 이 인스턴스를 구현하는 함수는 `>`, `>=`, `<`, `<=`이다.

### Show 타입 클래스
- `Show` 타입 클래스는 타입의 값을 문자열처럼 표시할 수 있도록 해준다.
- `show` 함수를 통해 `Show` 타입 클래스의 인스턴스를 문자열처럼 출력할 수 있다.
    - ex) `show 5 == "5"`

### Read 타입 클래스
- `Read` 타입 클래스는 `Show` 타입 클래스와 반대로 문자열을 타입의 값으로 변경할 수 있도록 해준다.
- `read` 함수를 통해 문자열을 `Read` 타입 클래스의 인스턴스로 변경할 수 있다.
    - ex) `read "True" == True`
    - `read` 함수로 `Read`의 인스턴스인 값을 받을 때, 타입을 특정할 수 없는 경우에는 타입 어노테이션(type annotation)을 사용한다.
        - 타입 어노테이션은 표현식의 타입이 무엇인지 명시적으로 알려주는 방법이다.
        - 표현식의 끝에 `::` 키워드를 추가한 다음에 타입을 지정하면 된다.
        - ex) `(read "5" :: Int) == 5`

### Enum 타입 클래스
- `Enum` 타입 클래스는 연속적으로 순서가 있는 타입을 정의할 수 있도록 해준다.
- 이 인스턴스는 값들을 열거할 수 있고, 리스트의 범위 안의 값들을 사용할 수 있다.
- 또한 `succ` 함수와 `pred` 함수로 얻을 수 있는 다음 항목(successor)과 이전 항목(predecessor)도 정의되어 있다.
    - ex) `['a'..'e'] == ['a', 'b', 'c', 'd', 'e']`

### Bounded 타입 클래스
- `Bounded` 타입 클래스는 상한계와 하한계를 가질 수 있도록 해준다.
- 이 인스턴스는 `minBound` 함수와 `maxBound` 함수를 이용하여 상한계와 하한계를 확인할 수 있다.
    - ex) `(minBound :: Bool) == False`
    - `minBound` 함수와 `maxBound` 함수는 매개변수가 없기 때문에 다형성 상수(polymorphic constant)라고도 불린다.
- 구성 요소가 모두 `Bounded`의 인스턴스인 튜플은 그 역시 `Bounded`의 인스턴스로 간주된다.
    - ex) `(maxBound :: (Bool, Char)) == (True,'\1114111')`

### Num 타입 클래스
- `Num` 타입 클래스는 숫자처럼 동작할 수 있도록 해준다.
- ex) `20 :: (Num t) => t`
- `Num` 타입 클래스를 구현한 타입 : `Int`, `Integer`, `Float`, `Double`
- `Num` 타입 클래스의 인스턴스가 되려면 타입은 이미 `Show`와 `Eq` 타입 클래스을 구현해야 한다.

### Floating 타입 클래스
- `Floating` 타입 클래스는 부동소수점수를 저장할 수 있도록 해준다.
- `Floating` 타입 클래스를 구현한 타입 : `Float`, `Double`

### Integral 타입 클래스
- `Integral` 타입 클래스는 정수처럼 동작할 수 있도록 해준다.
- 비슷해보이는 `Num` 타입 클래스는 실수를 포함한 모든 숫자를 포함한다.
- `Integral` 타입 클래스를 구현한 타입 : `Int`, `Integer`
- 정수를 처리하는데 특히 유용한 함수 중 하나는 `fromIntegral` 함수이다.
    - 타입 서명 : `fromIntegral :: (Integral a, Num b) => a -> b`
    - `Int` 타입과 부동소수점수를 연산할 때 `fromIntegral` 함수를 통해 `Int` 타입을 좀 더 일반적인 숫자로 바꿔야 한다.
<br><br>


## 타입 클래스에 대한 마지막 정리
- 타입 클래스는 추상 인터페이스를 정의하기 때문에 하나의 타입이 여러 타입 클래스들의 인스턴스가 될 수 있다.
- 또한 하나의 타입 클래스는 여러 가지 타입들을 인스턴스처럼 가질 수 있다.
- 어떤 타입은 특정 타입 클래스의 인스턴스가 되기 위해 반드시 다른 타입 클래스의 인스턴스이어야 한다. (`전제조건`)
    - ex) `Ord` 타입 클래스의 인스턴스가 되기 위해서는 `Eq` 타입 클래스의 인스턴스가 먼저 되어야 한다.
<br><br>


