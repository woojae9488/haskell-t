# 시작하기

## 준비사항
- 사용할 하스켈 컴파일러 : `GHC` (Glasgow Haskell Compiler)
    - 하스켈 스크립트(`.hs` 확장자를 가진 스크립트) 컴파일 가능
    - 인터랙티브 모드(`GHCi`)도 제공 (`ghci` 명령어를 통해 실행)
- 하스켈 플랫폼 다운로드 : https://www.haskell.org/downloads/

### GHCi 프로그램의 명령어
- `:l ${haskell script}` : 하스켈 스크립트 불러오기 (load)
- `:r` : 하스켈 스크립트 다시 불러오기 (reload)
- `:q` : GHCi 프로그램 종료 (quit)
- `:! ${cmd}` : shell에서 cmd 명령어 실행
- `:set prompt "${prompt format}"` : GHCi 프로그램의 프롬프트 형식 변경

### GHCi 프로그램의 기본 설정 변경
- GHCi 프로그램을 실행하는 홈 디렉터리에 `.ghci`라는 파일을 만든 후 명령어 추가
- 기본적으로 `:set prompt` 명령을 통해 프롬프트 형식을 변경한다.
<br><br>

## 함수 호출하기
- 중위 함수(infix function) : 함수명이 매개변수 2개 사이에 오는 함수
    - 기본적인 연산자들이 중위 함수로 작동한다.
- 전위 함수(prefix function) : 함수명이 매개변수들 앞에 오는 함수
    - 대부분의 함수들은 전위 함수로 작동한다.
    - 2개의 매개변수를 받는 전위 함수는 역 따옴표(`)로 함수명을 감싸면 중위 함수처럼 사용할 수 있다.
        - ex) `div 50 10`은 ``50 `div` 10``과 동일하다.
- 함수명은 대문자로 시작할 수 없으며, 어퍼스트로피(')는 함수명으로 유요한 문자이다.
- 함수명 끝에 어퍼스트로피를 붙이면 비슷한 이름을 가진 함수의 약간 다른 버전을 의미한다.
<br><br>

## 조건문 if 문
- 구문 : `if ${조건식} then ${참 값} else ${거짓 값}`
- 하스켈에서는 if 문에서 else 부분이 필수적이다.
- 하스켈의 if 문은 값을 반환해야 하는 표현식으로 동작한다.
<br><br>

## 리스트 소개
- 리스트는 같은 종류의 데이터 구조이다. (동일한 타입의 여러 항목들을 가지고 있다.)
- 리스트는 대괄호로 둘러 쌓이며, 리스트의 값은 콤마로 구분된다.
    - ex) `myList = [1, 2, 3, 4, 5]`
- 하스켈에서 문자열은 문자들의 리스트와 동일하다.
    - ex) `"hello" == ['h', 'e', 'l', 'l', 'o']`

### 리스트 연결
- `++` 연산자를 사용하여 리스트 2개를 연결할 수 있다.
    - ex) `[1, 2, 3] ++ [4, 5, 6] == [1, 2, 3, 4, 5, 6]`
- 긴 문자열에서 `++` 연산자를 반복적으로 사용하는 것은 지양해야 한다.
    - `++` 연산자는 첫 번째 리스트 전체를 읽어들여야 하기 때문이다.
- `:` 연산자(cons 연산자)를 사용하여 리스트의 시작 부분에 항목을 추가할 수 있다.
    - ex) `1:[2, 3, 4, 5] == [1, 2, 3, 4, 5]`
    - `:` 연산자는 리스트 전체를 읽어들이지 않고 즉각적으로 항목이 추가된다.

### 리스트 항목에 접근하기
- `!!` 연산자를 사용하면 리스트 항목을 인덱스로 접근할 수 있다.
    - ex) `[1, 2, 3, 4, 5] !! 0 == 1`

### 리스트 안의 리스트
- 리스트는 리스트를 항목으로 가질 수 있으며, 리스트를 항목으로 가진 리스트를 가질 수 있다.
    - ex) `matrix = [[1, 2], [3, 4], [5, 6]]`
- 리스트에 있는 리스트의 길이는 다를 수 있지만, 타입은 같아야 한다.

### 리스트 비교하기
- 리스트가 담고 있는 항목이 비교될 수 있다면 리스트도 비교될 수 있다.
- 2개의 리스트를 비교하기 위해 `<`, `<=`, `>`, `>=` 연산자를 사용하면 사전적 순서로 비교하게 된다.
    - 첫 번째 항목부터 시작해서 다음 항목들을 순차적으로 비교한다.
- 비어있지 않은 리스트는 비어있는 리스트보다 항상 크다고 간주된다.

### 더 많은 리스트 연산
- `head` 함수는 리스트를 받아서 첫 번째 항목을 반환한다.
    - ex) `head [1, 2, 3, 4, 5] == 1`
- `tail` 함수는 리스트를 받아서 첫 번째 항목을 제외한 나머지를 반환한다.
    - ex) `tail [1, 2, 3, 4, 5] == [2, 3, 4, 5]`
- `last` 함수는 리스트를 받아서 제일 마지막 항목을 반환한다.
    - ex) `last [1, 2, 3, 4, 5] == 5`
- `init` 함수는 리스트를 받아서 제일 마지막 항목을 제외한 나머지를 반환한다.
    - ex) `init [1, 2, 3, 4, 5] == [1, 2, 3, 4]`
- 위 4개의 함수들은 비어있는 리스트가 인자로 전달 시 에러가 던져진다.
- `length` 함수는 리스트를 받아서 그 길이를 반환한다.
    - ex) `length [1, 2, 3, 4, 5] == 5`
- `null` 함수는 리스트가 비어있는지 검사한다.
    - ex) `null [1, 2, 3, 4, 5] == False`
- `reverse` 함수는 리스트를 역순으로 만든다.
    - ex) `reverse [1, 2, 3, 4, 5] == [5, 4, 3, 2, 1]`
- `take` 함수는 숫자와 리스트를 받아 리스트의 시작 부분부터 주어진 숫자까지의 항목을 추출한다.
    - ex) `take 3 [1, 2, 3, 4, 5] == [1, 2, 3]`
    - 리스트에 있는 것보다 더 많은 항목을 얻으려고 하면 리스트 전체를 반환한다.
- `drop` 함수는 숫자와 리스트를 받아 리스트의 시작 부분부터 주어진 숫자까지의 항목을 버린다.
    - ex) `drop 3 [1, 2, 3, 4, 5] == [4, 5]`
- `maximum` 함수는 순서를 매길 수 있는 항목들의 리스트를 받아 가장 큰 항목을 반환한다.
    - ex) `maximum [1, 2, 3, 4, 5] == 5`
- `minimum` 함수는 순서를 매길 수 있는 항목들의 리스트를 받아 가장 작은 항목을 반환한다.
    - ex) `minimum [1, 2, 3, 4, 5] == 1`
- `sum` 함수는 숫자들의 리스트를 받아서 그들의 합을 반환한다.
    - ex) `sum [1, 2, 3, 4, 5] == 15`
- `product` 함수는 숫자들의 리스트를 받아서 그들의 곱을 반환한다.
    - ex) `product [1, 2, 3, 4, 5] == 120`
- `elem` 함수는 어떤 항목과 항목들의 리스트를 받아서 그 항목이 리스트의 항목인지를 검사한다.
    - ex) ``(3 `elem` [1, 2, 3, 4, 5]) == True``
- `replicate` 함수는 하나의 항목으로 구성된 리스트를 만드는 가장 쉬운 방법이다.
    - ex) `replicate 5 5 == [5, 5, 5, 5, 5]`
<br><br>

## 범위
- 범위는 열거될 수 있거나 순서대로 번호를 줄 수 있는 항목들로 구성된 리스트를 만든다.
- 구문 : `[${시작 값}..${종료 값}]`
    - ex) `[1..5] == [1, 2, 3, 4, 5]`
- 범위 안에 항목들 간의 간격을 지정할 수도 있다.
- 구문 : `[${첫 번째 값}, ${두 번째 값}..${종료 값}]`
    - ex) `[1, 3..9] == [1, 3, 5, 7, 9]`
    - 내림차순 리스트를 만들기 위해서는 간격 구문을 사용해서 만들어야 한다.
        - ex) `[5, 4..1] == [5, 4, 3, 2, 1]`
- 범위에서 종료 값을 지정하지 않으면 무한 리스트를 만들 수도 있다.
    - ex) `take 5 [1, 2..] == [1, 2, 3, 4, 5]`
    - 하스켈은 느긋한 언어이기 때문에 무한 리스트를 즉시 구하려고 하지 않는다.
- 무한 리스트를 만들기 위해 여러 함수들이 사용된다.
    - `cycle` 함수는 리스트를 받아서 항목들은 무한히 복제한다.
        - ex) `take 6 (cycle [1, 2, 3]) == [1, 2, 3, 1, 2, 3]`
    - `repeat` 함수는 항목을 받아서 그 항목으로만 무한 리스트를 만든다.
        - ex) `take 5 (repeat 5) == [5, 5, 5, 5, 5]`
<br><br>

## 리스트 통합
- 리스트 통합은 리스트를 검색하고 이동하며 결합하기 위한 방법이다.
- 리스트 통합은 수학의 `조건제시법`(set comprehensions) 개념과 매우 비슷하다.
- 구문 : `[${결과부} | ${항목부}]`
    - ex) `[x*2 | x <- [1..5]] == [2, 4, 6, 8, 10]`
    - 결과부는 결과 리스트에 반영될 항목들이 어떠해야 하는지를 지정한다.
    - 항목부는 각 항목과 결과 부의 변수를 바인딩한다.
    - 항목부는 콤마로 구분한다면 원하는 만큼 포함시킬 수 있다.
        ex) `[x*y | x <- [1..2], y <- [1..3]] == [1, 2, 3, 2, 4, 6]`
        - 첫 항목부의 항목을 하나씩 가져온 후 이후 항목부에 대한 결과를 순차적으로 추가한다. 
- 통합 작업에 서술부를 추가할 수도 있다.
    - 구문 : `[${결과부} | ${항목부}, ${서술부}]`
    - ex) `[x*2 | x <- [1..10], x*2 <= 10] == [2, 4, 6, 8, 10]`
    - 서술부는 리스트 통합 작업에 조건을 지정한다.
    - 서술부를 이용해서 리스트의 일부를 없애는 것을 `필터링`이라고도 한다.
    - 서술부는 콤마로 구분한다면 원하는 만큼 포함시킬 수 있다.
        ex) `[x | x <- [1..7], x /= 6, x /= 7] == [1, 2, 3, 4, 5]`
- `length` 함수를 직접 만들기 위해 리스트 결합을 사용할 수도 있다.
    - 결과 : `length' xs = sum [1 | _ <- xs]`
        - 입력 리스트에서 가져온 항목을 사용하지 않으려면 임시 변수로 밑줄(_)을 사용할 수 있다.
- 중첩 리스트를 위해 중첩 리스트 결합을 사용할 수도 있다.
    - ex) `[ [x | x <- xs, even x] | xs <- xxs ]`
- 리스트 결합에 대한 가독성을 높이기 위해 여러 줄로 나눠서 작성할 수도 있다.
<br><br>
